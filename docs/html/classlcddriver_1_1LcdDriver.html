<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TivaC Lcd Driver for 1602A LCD controller: lcddriver::LcdDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TivaC Lcd Driver for 1602A LCD controller
   </div>
   <div id="projectbrief">A c++ driver for interfacing the TivaC with the 1602A LCD controller</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelcddriver.html">lcddriver</a></li><li class="navelem"><a class="el" href="classlcddriver_1_1LcdDriver.html">LcdDriver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlcddriver_1_1LcdDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lcddriver::LcdDriver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main class for the <a class="el" href="classlcddriver_1_1LcdDriver.html" title="The main class for the LcdDriver, all interactions with the 1602 lcd controller will be through this ...">LcdDriver</a>, all interactions with the 1602 lcd controller will be through this class.  
 <a href="classlcddriver_1_1LcdDriver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lcd__driver_8hpp_source.html">lcd_driver.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for lcddriver::LcdDriver:</div>
<div class="dyncontent">
<div class="center"><img src="classlcddriver_1_1LcdDriver__coll__graph.png" border="0" usemap="#lcddriver_1_1LcdDriver_coll__map" alt="Collaboration graph"/></div>
<map name="lcddriver_1_1LcdDriver_coll__map" id="lcddriver_1_1LcdDriver_coll__map">
<area shape="rect" id="node2" href="structlcddriver_1_1LcdConfig.html" title="the structure used for carrying the lcd controller settings Each pin description is an array of 3 mem..." alt="" coords="5,5,144,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00c982d44d1e617b1e9db474c79048f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a00c982d44d1e617b1e9db474c79048f1">LcdDriver</a> (const <a class="el" href="structlcddriver_1_1LcdConfig.html">LcdConfig</a> &amp;lcdConfig)</td></tr>
<tr class="memdesc:a00c982d44d1e617b1e9db474c79048f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Lcd Driver object, doesn't initiate any hardware, just compute data to be ready for future operations.  <a href="#a00c982d44d1e617b1e9db474c79048f1">More...</a><br /></td></tr>
<tr class="separator:a00c982d44d1e617b1e9db474c79048f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cb472461579d9fbf92df052c37743b"><td class="memItemLeft" align="right" valign="top"><a id="a11cb472461579d9fbf92df052c37743b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a11cb472461579d9fbf92df052c37743b">init</a> (void)</td></tr>
<tr class="memdesc:a11cb472461579d9fbf92df052c37743b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the lcd driver, by turning on all gpio clocks and set the gpio mode to be ready to drive the lcd. <br /></td></tr>
<tr class="separator:a11cb472461579d9fbf92df052c37743b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2084c57dda256528984c8b08ca789178"><td class="memItemLeft" align="right" valign="top"><a id="a2084c57dda256528984c8b08ca789178"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a2084c57dda256528984c8b08ca789178">enable</a> (void)</td></tr>
<tr class="memdesc:a2084c57dda256528984c8b08ca789178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start communicating with the lcd and write settings to the lcd controller, this might take more than other operations since it will wait the recommended amount of time in the manual for the lcd to warm up. <br /></td></tr>
<tr class="separator:a2084c57dda256528984c8b08ca789178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4646ada2ed1929a626a246e57106e9cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a4646ada2ed1929a626a246e57106e9cd">displayWrite</a> (const char *dataToWrite)</td></tr>
<tr class="memdesc:a4646ada2ed1929a626a246e57106e9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the display and add new text to it starting at position (0,0), this method will be the one used the most as it offers the most straightforward interface to writing to the LCD.  <a href="#a4646ada2ed1929a626a246e57106e9cd">More...</a><br /></td></tr>
<tr class="separator:a4646ada2ed1929a626a246e57106e9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d620706bbc757a3179e71ca1e747ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a42d620706bbc757a3179e71ca1e747ff">displayAppend</a> (const char *dataToAppend)</td></tr>
<tr class="memdesc:a42d620706bbc757a3179e71ca1e747ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append text to existing text onscreen, this method will also be used the most if there is no need to modify the deeper level API Note that during other operation, the cursor might have been moved, if that happens, it's best to use the cursorPositionChange to get back to the desired position and continue printing text.  <a href="#a42d620706bbc757a3179e71ca1e747ff">More...</a><br /></td></tr>
<tr class="separator:a42d620706bbc757a3179e71ca1e747ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd0e35d6f95a94dc189a629b7d150d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a3fd0e35d6f95a94dc189a629b7d150d2">newCustomCharAdd</a> (const uint8_t charPattern[CUSTOM_CHAR_PATTERN_LEN], const uint32_t &amp;customCharSlot)</td></tr>
<tr class="memdesc:a3fd0e35d6f95a94dc189a629b7d150d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new custom character pattern The new pattern will be stored in the custom generator RAM of the lcd controller, the 1602 can store 8 5x8 or 4 5x10 pattern.  <a href="#a3fd0e35d6f95a94dc189a629b7d150d2">More...</a><br /></td></tr>
<tr class="separator:a3fd0e35d6f95a94dc189a629b7d150d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af580a1611399fdebe83ae9d768459ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#af580a1611399fdebe83ae9d768459ace">lcdSettingSwitch</a> (const bool &amp;displayOn, const bool &amp;cursorOn, const bool &amp;cursorBlinkOn)</td></tr>
<tr class="memdesc:af580a1611399fdebe83ae9d768459ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change lcd settings like on/off display, cursor, or blinking mode This method writes to the lcd controller register to set the settings.  <a href="#af580a1611399fdebe83ae9d768459ace">More...</a><br /></td></tr>
<tr class="separator:af580a1611399fdebe83ae9d768459ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410f464c8a90b54d0d8c6e6937cfa94f"><td class="memItemLeft" align="right" valign="top"><a id="a410f464c8a90b54d0d8c6e6937cfa94f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a410f464c8a90b54d0d8c6e6937cfa94f">lcdReset</a> (void)</td></tr>
<tr class="memdesc:a410f464c8a90b54d0d8c6e6937cfa94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the LCD and erase all RAM, also reset cursor to (0,0) <br /></td></tr>
<tr class="separator:a410f464c8a90b54d0d8c6e6937cfa94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0479132b5064e3450f201ed6432e9189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a0479132b5064e3450f201ed6432e9189">cursorPositionChange</a> (const uint8_t &amp;cursorX, const uint8_t &amp;cursorY)</td></tr>
<tr class="memdesc:a0479132b5064e3450f201ed6432e9189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change cursor position on an x-y scale This method also changes the data ram position with the cursor so future texts will be printed at the cursor.  <a href="#a0479132b5064e3450f201ed6432e9189">More...</a><br /></td></tr>
<tr class="separator:a0479132b5064e3450f201ed6432e9189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ee1df7f08fef1b4a6df4e78482020f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ae0ee1df7f08fef1b4a6df4e78482020f">backLedSwitch</a> (const bool &amp;isBackLedOn)</td></tr>
<tr class="memdesc:ae0ee1df7f08fef1b4a6df4e78482020f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off the back light LED The TivaC itself probably doesn't have the current to turn on or off the backLight alone so probably use a relay or a transistor.  <a href="#ae0ee1df7f08fef1b4a6df4e78482020f">More...</a><br /></td></tr>
<tr class="separator:ae0ee1df7f08fef1b4a6df4e78482020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4d5c1401c84bbaa553624bf7bfc4b74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a4d5c1401c84bbaa553624bf7bfc4b74e">parallelDataRead</a> (const bool &amp;isDataReg, uint8_t *readDataBuf, const uint32_t &amp;totalReadData)</td></tr>
<tr class="memdesc:a4d5c1401c84bbaa553624bf7bfc4b74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for reading the data from the controller RAM/program memory The method will follow procedures outlined in the datasheet to intiate and read data from the controller, if using 4 pins it will take two transfers to deliver 8 bits instead of 1 if using 8 pins  <a href="#a4d5c1401c84bbaa553624bf7bfc4b74e">More...</a><br /></td></tr>
<tr class="separator:a4d5c1401c84bbaa553624bf7bfc4b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68868010d59b575695e32003e566390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#af68868010d59b575695e32003e566390">parallelDataWrite</a> (const uint8_t *dataList, const uint32_t &amp;dataLen, const bool &amp;isDataReg)</td></tr>
<tr class="memdesc:af68868010d59b575695e32003e566390"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for sending data to the data pins(D0-D7) connected to the LCD The bits are shifted to each pin and then a proper setup and hold time is followed to make sure that the controller receives the data, the method will follow the correct procedure to intitiate connection with the controller  <a href="#af68868010d59b575695e32003e566390">More...</a><br /></td></tr>
<tr class="separator:af68868010d59b575695e32003e566390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d39861c1faba7371d17be41b7011bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a30d39861c1faba7371d17be41b7011bb">parallelDataWriteSingle</a> (const uint8_t &amp;data, const bool &amp;isDataReg)</td></tr>
<tr class="memdesc:a30d39861c1faba7371d17be41b7011bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for writing a single byte to the lcd controller  <a href="#a30d39861c1faba7371d17be41b7011bb">More...</a><br /></td></tr>
<tr class="separator:a30d39861c1faba7371d17be41b7011bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d0a21ac75d28bafbbd674ef566555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#aa91d0a21ac75d28bafbbd674ef566555">parallelModeSwitch</a> (const bool &amp;isInput)</td></tr>
<tr class="memdesc:aa91d0a21ac75d28bafbbd674ef566555"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch all the data pins(like D0-D7) to input mode or output mode Used for quickly switching between receiving and sending data  <a href="#aa91d0a21ac75d28bafbbd674ef566555">More...</a><br /></td></tr>
<tr class="separator:aa91d0a21ac75d28bafbbd674ef566555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6060a18e4cad2b7e141b4c80da96bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a4e6060a18e4cad2b7e141b4c80da96bc">pinModeSwitch</a> (const uint32_t pinDesc[PIN_DESCRIPTION_LEN], const bool &amp;isInput)</td></tr>
<tr class="memdesc:a4e6060a18e4cad2b7e141b4c80da96bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch a single pin to input/output  <a href="#a4e6060a18e4cad2b7e141b4c80da96bc">More...</a><br /></td></tr>
<tr class="separator:a4e6060a18e4cad2b7e141b4c80da96bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e98eb8654648d6cca19c63aca0398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ac39e98eb8654648d6cca19c63aca0398">pinWrite</a> (const uint32_t pinDesc[PIN_DESCRIPTION_LEN], const bool &amp;output)</td></tr>
<tr class="memdesc:ac39e98eb8654648d6cca19c63aca0398"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch on/off a pin This is the lowest level function, used for toggling control pin for bitbanging during communcication  <a href="#ac39e98eb8654648d6cca19c63aca0398">More...</a><br /></td></tr>
<tr class="separator:ac39e98eb8654648d6cca19c63aca0398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8e8816db117e129c29bdbf8fdca3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a30f8e8816db117e129c29bdbf8fdca3d">pinRead</a> (const uint32_t pinDesc[PIN_DESCRIPTION_LEN])</td></tr>
<tr class="memdesc:a30f8e8816db117e129c29bdbf8fdca3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whehther a pin is high or low.  <a href="#a30f8e8816db117e129c29bdbf8fdca3d">More...</a><br /></td></tr>
<tr class="separator:a30f8e8816db117e129c29bdbf8fdca3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93289cc0da86c9081c6078aaddef9c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a93289cc0da86c9081c6078aaddef9c57">pinPadConfig</a> (const uint32_t pinDesc[PIN_DESCRIPTION_LEN])</td></tr>
<tr class="memdesc:a93289cc0da86c9081c6078aaddef9c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">configure the pins on things like drive strength(affect rise/fall time of signal), push/pull mode  <a href="#a93289cc0da86c9081c6078aaddef9c57">More...</a><br /></td></tr>
<tr class="separator:a93289cc0da86c9081c6078aaddef9c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfe7221754786680d8bca6d8500539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a8cbfe7221754786680d8bca6d8500539">pinDescCheck</a> (uint32_t pinDesc[PIN_DESCRIPTION_LEN])</td></tr>
<tr class="memdesc:a8cbfe7221754786680d8bca6d8500539"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the array describing a pin is valid, will raise assert if not  <a href="#a8cbfe7221754786680d8bca6d8500539">More...</a><br /></td></tr>
<tr class="separator:a8cbfe7221754786680d8bca6d8500539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe7679481c3e656b8bfba075c99cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a0cfe7679481c3e656b8bfba075c99cce">comSetup</a> (const bool &amp;isDataReg, const bool &amp;isReadMode)</td></tr>
<tr class="memdesc:a0cfe7679481c3e656b8bfba075c99cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to generate signal to start the communication with the lcd controller The method will put the RS, RW line in the correct mode(depending on other params passed to this function), pull high enable pin and then wait for the signal to become stable then exit.  <a href="#a0cfe7679481c3e656b8bfba075c99cce">More...</a><br /></td></tr>
<tr class="separator:a0cfe7679481c3e656b8bfba075c99cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade95becbcc3b6afc74c5bfe3098bac75"><td class="memItemLeft" align="right" valign="top"><a id="ade95becbcc3b6afc74c5bfe3098bac75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ade95becbcc3b6afc74c5bfe3098bac75">comStop</a> (void)</td></tr>
<tr class="memdesc:ade95becbcc3b6afc74c5bfe3098bac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop the communcation by waiting for the current data to be finished transacting and then deassert the enable line <br /></td></tr>
<tr class="separator:ade95becbcc3b6afc74c5bfe3098bac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6479c25d6c22593c5b154a473e759fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a6479c25d6c22593c5b154a473e759fb1">comMaintain</a> (const bool &amp;isReadMode)</td></tr>
<tr class="memdesc:a6479c25d6c22593c5b154a473e759fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">temporarily deassert the enable line, wait for the current data to be finished transacting and then asser the enable line again to continue communication  <a href="#a6479c25d6c22593c5b154a473e759fb1">More...</a><br /></td></tr>
<tr class="separator:a6479c25d6c22593c5b154a473e759fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992046369aafb0c93d9eb02b0e5fbc64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a992046369aafb0c93d9eb02b0e5fbc64">registerSelect</a> (const bool &amp;isDataReg)</td></tr>
<tr class="memdesc:a992046369aafb0c93d9eb02b0e5fbc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">select data(like RAM) or program register be switching the RS line  <a href="#a992046369aafb0c93d9eb02b0e5fbc64">More...</a><br /></td></tr>
<tr class="separator:a992046369aafb0c93d9eb02b0e5fbc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85314fc5ad6d0cea492646e2bfd9138"><td class="memItemLeft" align="right" valign="top"><a id="ab85314fc5ad6d0cea492646e2bfd9138"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ab85314fc5ad6d0cea492646e2bfd9138">configWrite</a> (void)</td></tr>
<tr class="memdesc:ab85314fc5ad6d0cea492646e2bfd9138"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for writing configs to controller, uses other functions like functionSetCommandCreate to get the command then push it to the lcd controller <br /></td></tr>
<tr class="separator:ab85314fc5ad6d0cea492646e2bfd9138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42022ba00cd20640952cef89226e281e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a42022ba00cd20640952cef89226e281e">comSwitch</a> (const bool &amp;iscomEnabled)</td></tr>
<tr class="memdesc:a42022ba00cd20640952cef89226e281e"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn on or off communication by switching the EN pin  <a href="#a42022ba00cd20640952cef89226e281e">More...</a><br /></td></tr>
<tr class="separator:a42022ba00cd20640952cef89226e281e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa7d4eb6b9841a4d5dce649b07260a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a0aa7d4eb6b9841a4d5dce649b07260a3">comModeSwitch</a> (const bool &amp;isReadMode)</td></tr>
<tr class="memdesc:a0aa7d4eb6b9841a4d5dce649b07260a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch to read/write mode by switching RW pin  <a href="#a0aa7d4eb6b9841a4d5dce649b07260a3">More...</a><br /></td></tr>
<tr class="separator:a0aa7d4eb6b9841a4d5dce649b07260a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e463ef18ca73b8e50d5408b771962"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a355e463ef18ca73b8e50d5408b771962">entryModeCommandCreate</a> (const bool &amp;cursorRightDir, const bool &amp;displayShiftEnabled)</td></tr>
<tr class="memdesc:a355e463ef18ca73b8e50d5408b771962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a command of entry mode category.  <a href="#a355e463ef18ca73b8e50d5408b771962">More...</a><br /></td></tr>
<tr class="separator:a355e463ef18ca73b8e50d5408b771962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4c46995e97053025c37968f9306831"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a5f4c46995e97053025c37968f9306831">displayCommandCreate</a> (const bool &amp;displayOn, const bool &amp;cursorOn, const bool &amp;isCursorBlink)</td></tr>
<tr class="memdesc:a5f4c46995e97053025c37968f9306831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a command of display category.  <a href="#a5f4c46995e97053025c37968f9306831">More...</a><br /></td></tr>
<tr class="separator:a5f4c46995e97053025c37968f9306831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9fb39c91825d62d770c3094bfcaf0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a7fd9fb39c91825d62d770c3094bfcaf0">functionSetCommandCreate</a> (const bool &amp;is8BitDataLen, const bool &amp;is2Lines, const bool &amp;is5x10Font)</td></tr>
<tr class="memdesc:a7fd9fb39c91825d62d770c3094bfcaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a command of function set category.  <a href="#a7fd9fb39c91825d62d770c3094bfcaf0">More...</a><br /></td></tr>
<tr class="separator:a7fd9fb39c91825d62d770c3094bfcaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a3ccda389903b6c77ee0e5b7eca42c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a98a3ccda389903b6c77ee0e5b7eca42c">cursorDisplayShiftCommandCreate</a> (const bool &amp;isShiftDisplay, const bool &amp;isRight)</td></tr>
<tr class="memdesc:a98a3ccda389903b6c77ee0e5b7eca42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a command to shift the cursor and maybe the display with it  <a href="#a98a3ccda389903b6c77ee0e5b7eca42c">More...</a><br /></td></tr>
<tr class="separator:a98a3ccda389903b6c77ee0e5b7eca42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff6e0cb046d5e338af031fb84613a7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#aaff6e0cb046d5e338af031fb84613a7b">lcdIsBusy</a> (void)</td></tr>
<tr class="memdesc:aaff6e0cb046d5e338af031fb84613a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read lcd controller memory and see if the lcd is busy with an operation.  <a href="#aaff6e0cb046d5e338af031fb84613a7b">More...</a><br /></td></tr>
<tr class="separator:aaff6e0cb046d5e338af031fb84613a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fabbf7c4e4e52cd3cb0a18b83b83fd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ab9fabbf7c4e4e52cd3cb0a18b83b83fd">addrCounterGet</a> (void)</td></tr>
<tr class="memdesc:ab9fabbf7c4e4e52cd3cb0a18b83b83fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read lcd controller memory to retrieve the 7 bits address counter This command can be helpful during debug to probe what memories are being read.  <a href="#ab9fabbf7c4e4e52cd3cb0a18b83b83fd">More...</a><br /></td></tr>
<tr class="separator:ab9fabbf7c4e4e52cd3cb0a18b83b83fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c12042d4c493c8e8e4212e00b461cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a6c12042d4c493c8e8e4212e00b461cab">addrCounterChange</a> (const uint8_t &amp;addr, const bool &amp;isDataRam)</td></tr>
<tr class="memdesc:a6c12042d4c493c8e8e4212e00b461cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the address counter on the lcd controller This command is used a lot since it changes the address counter to be ready for the read/write operation.  <a href="#a6c12042d4c493c8e8e4212e00b461cab">More...</a><br /></td></tr>
<tr class="separator:a6c12042d4c493c8e8e4212e00b461cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aab81cc16421ec9559cb0b8ffbd03e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#aa4aab81cc16421ec9559cb0b8ffbd03e">dataWrite4Bit</a> (const uint32_t &amp;dataToWrite, const bool &amp;stopAfterWrite)</td></tr>
<tr class="memdesc:aa4aab81cc16421ec9559cb0b8ffbd03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to write only 4 bits using D4-D7 This command is used mainly during the beginning of the communication where all data is sent using 4 pins only once instead of 4 pins twice like the rest of the communication.  <a href="#aa4aab81cc16421ec9559cb0b8ffbd03e">More...</a><br /></td></tr>
<tr class="separator:aa4aab81cc16421ec9559cb0b8ffbd03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3e2c0fa93c8e3911d01f4c4e7e6c09"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a5c3e2c0fa93c8e3911d01f4c4e7e6c09">instructionDataRead</a> (void)</td></tr>
<tr class="memdesc:a5c3e2c0fa93c8e3911d01f4c4e7e6c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the lcd controller data to get the busy status and current address counter.  <a href="#a5c3e2c0fa93c8e3911d01f4c4e7e6c09">More...</a><br /></td></tr>
<tr class="separator:a5c3e2c0fa93c8e3911d01f4c4e7e6c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d517b0e77d0b957b2c84d6bba76d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a86d517b0e77d0b957b2c84d6bba76d97">ramDataWrite</a> (const uint8_t *data, const uint32_t dataLen, const bool &amp;isTextMode)</td></tr>
<tr class="memdesc:a86d517b0e77d0b957b2c84d6bba76d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the RAM of the lcd controller, can be data ram or character generator RAM.  <a href="#a86d517b0e77d0b957b2c84d6bba76d97">More...</a><br /></td></tr>
<tr class="separator:a86d517b0e77d0b957b2c84d6bba76d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68acf86a54398434990ed133f19e0be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a68acf86a54398434990ed133f19e0be6">ramDataRead</a> (uint8_t *returnData, const uint32_t &amp;totalDataRead, const uint8_t &amp;startingRamAddr, const bool &amp;isDataRam)</td></tr>
<tr class="memdesc:a68acf86a54398434990ed133f19e0be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reading the RAM of the lcd controller, it can either be the data ram storing data to be displayed or the character generator ram, storing custom pattern The reading operation may result in the cursor moving.  <a href="#a68acf86a54398434990ed133f19e0be6">More...</a><br /></td></tr>
<tr class="separator:a68acf86a54398434990ed133f19e0be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae3dc6de0807e9ef7f5e86b7c8a616249"><td class="memItemLeft" align="right" valign="top"><a id="ae3dc6de0807e9ef7f5e86b7c8a616249"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#ae3dc6de0807e9ef7f5e86b7c8a616249">_totalBitPerPin</a></td></tr>
<tr class="memdesc:ae3dc6de0807e9ef7f5e86b7c8a616249"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many bits that each pin has to send, if using 8 then each only has to send 1, but if 4 then each has to do 2. <br /></td></tr>
<tr class="separator:ae3dc6de0807e9ef7f5e86b7c8a616249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e239e00c4677f93b6f5082615d169bc"><td class="memItemLeft" align="right" valign="top"><a id="a2e239e00c4677f93b6f5082615d169bc"></a>
<a class="el" href="structlcddriver_1_1LcdConfig.html">LcdConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#a2e239e00c4677f93b6f5082615d169bc">_lcdConfig</a></td></tr>
<tr class="memdesc:a2e239e00c4677f93b6f5082615d169bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classlcddriver_1_1LcdDriver.html" title="The main class for the LcdDriver, all interactions with the 1602 lcd controller will be through this ...">LcdDriver</a> copy of the user config received at constructor. <br /></td></tr>
<tr class="separator:a2e239e00c4677f93b6f5082615d169bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecfb67a2b072cf12de07718c6024f58"><td class="memItemLeft" align="right" valign="top"><a id="aaecfb67a2b072cf12de07718c6024f58"></a>
GeneralTimer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcddriver_1_1LcdDriver.html#aaecfb67a2b072cf12de07718c6024f58">_generalTimer</a></td></tr>
<tr class="memdesc:aaecfb67a2b072cf12de07718c6024f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of general timer used for all timing purposes. <br /></td></tr>
<tr class="separator:aaecfb67a2b072cf12de07718c6024f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main class for the <a class="el" href="classlcddriver_1_1LcdDriver.html" title="The main class for the LcdDriver, all interactions with the 1602 lcd controller will be through this ...">LcdDriver</a>, all interactions with the 1602 lcd controller will be through this class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00c982d44d1e617b1e9db474c79048f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c982d44d1e617b1e9db474c79048f1">&#9670;&nbsp;</a></span>LcdDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lcddriver::LcdDriver::LcdDriver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlcddriver_1_1LcdConfig.html">LcdConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>lcdConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new Lcd Driver object, doesn't initiate any hardware, just compute data to be ready for future operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcdConfig</td><td>struct storing settings for lcd driver such as pin allocations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6c12042d4c493c8e8e4212e00b461cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c12042d4c493c8e8e4212e00b461cab">&#9670;&nbsp;</a></span>addrCounterChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::addrCounterChange </td>
          <td>(</td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataRam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the address counter on the lcd controller This command is used a lot since it changes the address counter to be ready for the read/write operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>address to change to </td></tr>
    <tr><td class="paramname">isDataRam</td><td>if true then the address to change to is part of the dataRAM, otherwise part of CGRAM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9fabbf7c4e4e52cd3cb0a18b83b83fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fabbf7c4e4e52cd3cb0a18b83b83fd">&#9670;&nbsp;</a></span>addrCounterGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::addrCounterGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read lcd controller memory to retrieve the 7 bits address counter This command can be helpful during debug to probe what memories are being read. </p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t the 7 bits address counter </dd></dl>

</div>
</div>
<a id="ae0ee1df7f08fef1b4a6df4e78482020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ee1df7f08fef1b4a6df4e78482020f">&#9670;&nbsp;</a></span>backLedSwitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::backLedSwitch </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isBackLedOn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn on or off the back light LED The TivaC itself probably doesn't have the current to turn on or off the backLight alone so probably use a relay or a transistor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isBackLedOn</td><td>turn on LED if true, off otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6479c25d6c22593c5b154a473e759fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6479c25d6c22593c5b154a473e759fb1">&#9670;&nbsp;</a></span>comMaintain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::comMaintain </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isReadMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>temporarily deassert the enable line, wait for the current data to be finished transacting and then asser the enable line again to continue communication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReadMode</td><td>is this transaction a read one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aa7d4eb6b9841a4d5dce649b07260a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa7d4eb6b9841a4d5dce649b07260a3">&#9670;&nbsp;</a></span>comModeSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::comModeSwitch </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isReadMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>switch to read/write mode by switching RW pin </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isReadMode</td><td>if true then RW is pulled high to indicate the next transaction to be a read one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cfe7679481c3e656b8bfba075c99cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfe7679481c3e656b8bfba075c99cce">&#9670;&nbsp;</a></span>comSetup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::comSetup </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isReadMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function used to generate signal to start the communication with the lcd controller The method will put the RS, RW line in the correct mode(depending on other params passed to this function), pull high enable pin and then wait for the signal to become stable then exit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDataReg</td><td>true if the target of the communication is the data section of the lcd controller(like DDRAM) </td></tr>
    <tr><td class="paramname">isReadMode</td><td>if true then the transaction is a read one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42022ba00cd20640952cef89226e281e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42022ba00cd20640952cef89226e281e">&#9670;&nbsp;</a></span>comSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::comSwitch </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>iscomEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>turn on or off communication by switching the EN pin </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iscomEnabled</td><td>true then EN pin pulled high, pulled low otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98a3ccda389903b6c77ee0e5b7eca42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a3ccda389903b6c77ee0e5b7eca42c">&#9670;&nbsp;</a></span>cursorDisplayShiftCommandCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::cursorDisplayShiftCommandCreate </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isShiftDisplay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a command to shift the cursor and maybe the display with it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isShiftDisplay</td><td>if true allow display to shift if required </td></tr>
    <tr><td class="paramname">isRight</td><td>if true, set the movement direction to right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t a command that can be sent to the lcd controller to control cursor movement </dd></dl>

</div>
</div>
<a id="a0479132b5064e3450f201ed6432e9189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0479132b5064e3450f201ed6432e9189">&#9670;&nbsp;</a></span>cursorPositionChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::cursorPositionChange </td>
          <td>(</td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>cursorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>cursorY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change cursor position on an x-y scale This method also changes the data ram position with the cursor so future texts will be printed at the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursorX</td><td>x coordinate to set, max at 15 for 16x2 lcd </td></tr>
    <tr><td class="paramname">cursorY</td><td>y coordinate to set, max at 1 for 16x2 lcd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4aab81cc16421ec9559cb0b8ffbd03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aab81cc16421ec9559cb0b8ffbd03e">&#9670;&nbsp;</a></span>dataWrite4Bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::dataWrite4Bit </td>
          <td>(</td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>dataToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>stopAfterWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to write only 4 bits using D4-D7 This command is used mainly during the beginning of the communication where all data is sent using 4 pins only once instead of 4 pins twice like the rest of the communication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToWrite</td><td>data to be written, most likely a command to setup communication </td></tr>
    <tr><td class="paramname">stopAfterWrite</td><td>if true terminate connection after write, otherwise maintain the connection with the lcd controller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d620706bbc757a3179e71ca1e747ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d620706bbc757a3179e71ca1e747ff">&#9670;&nbsp;</a></span>displayAppend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::displayAppend </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataToAppend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append text to existing text onscreen, this method will also be used the most if there is no need to modify the deeper level API Note that during other operation, the cursor might have been moved, if that happens, it's best to use the cursorPositionChange to get back to the desired position and continue printing text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToAppend</td><td>character array reprenting string to print, limited at 32 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4c46995e97053025c37968f9306831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4c46995e97053025c37968f9306831">&#9670;&nbsp;</a></span>displayCommandCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::displayCommandCreate </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>displayOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>cursorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isCursorBlink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a command of display category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayOn</td><td>if true, turn on display, otherwise off </td></tr>
    <tr><td class="paramname">cursorOn</td><td>if true, turn on cursor, otherwise off </td></tr>
    <tr><td class="paramname">isCursorBlink</td><td>if true, blink cursor, otherwise no blink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t a display command that can be sent to the lcd controller </dd></dl>

</div>
</div>
<a id="a4646ada2ed1929a626a246e57106e9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4646ada2ed1929a626a246e57106e9cd">&#9670;&nbsp;</a></span>displayWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::displayWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dataToWrite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the display and add new text to it starting at position (0,0), this method will be the one used the most as it offers the most straightforward interface to writing to the LCD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToWrite</td><td>character array reprenting string to print, limited at 32 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a355e463ef18ca73b8e50d5408b771962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355e463ef18ca73b8e50d5408b771962">&#9670;&nbsp;</a></span>entryModeCommandCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::entryModeCommandCreate </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>cursorRightDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>displayShiftEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a command of entry mode category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursorRightDir</td><td>if true, set the direction of movement to the right </td></tr>
    <tr><td class="paramname">displayShiftEnabled</td><td>if true, allow the display to be shifted when necessary(check the manual for this) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t an entry command that can be sent to the lcd controller </dd></dl>

</div>
</div>
<a id="a7fd9fb39c91825d62d770c3094bfcaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9fb39c91825d62d770c3094bfcaf0">&#9670;&nbsp;</a></span>functionSetCommandCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::functionSetCommandCreate </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>is8BitDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>is2Lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>is5x10Font</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a command of function set category. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is8BitDataLen</td><td>if true, then send data over 8 pins, otherwise, send data using 4 pins(D4-D7) </td></tr>
    <tr><td class="paramname">is2Lines</td><td>if true, display 2 lines on lcd, display 1 otherwise </td></tr>
    <tr><td class="paramname">is5x10Font</td><td>if true, use 5x10 font, use 5x8 font otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t a function set command that can be sent to the lcd controller </dd></dl>

</div>
</div>
<a id="a5c3e2c0fa93c8e3911d01f4c4e7e6c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3e2c0fa93c8e3911d01f4c4e7e6c09">&#9670;&nbsp;</a></span>instructionDataRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lcddriver::LcdDriver::instructionDataRead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the lcd controller data to get the busy status and current address counter. </p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t the busy bit(bit 7) and the address counter(bit 0-6) </dd></dl>

</div>
</div>
<a id="aaff6e0cb046d5e338af031fb84613a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff6e0cb046d5e338af031fb84613a7b">&#9670;&nbsp;</a></span>lcdIsBusy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lcddriver::LcdDriver::lcdIsBusy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read lcd controller memory and see if the lcd is busy with an operation. </p>
<dl class="section return"><dt>Returns</dt><dd>true lcd is doing an operation </dd>
<dd>
false lcd is idle </dd></dl>

</div>
</div>
<a id="af580a1611399fdebe83ae9d768459ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580a1611399fdebe83ae9d768459ace">&#9670;&nbsp;</a></span>lcdSettingSwitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::lcdSettingSwitch </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>displayOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>cursorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>cursorBlinkOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change lcd settings like on/off display, cursor, or blinking mode This method writes to the lcd controller register to set the settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayOn</td><td>display on if true, off otherwise </td></tr>
    <tr><td class="paramname">cursorOn</td><td>cursor on if true, off otherwise </td></tr>
    <tr><td class="paramname">cursorBlinkOn</td><td>cursor blinking on if true, off otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fd0e35d6f95a94dc189a629b7d150d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd0e35d6f95a94dc189a629b7d150d2">&#9670;&nbsp;</a></span>newCustomCharAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::newCustomCharAdd </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>charPattern</em>[CUSTOM_CHAR_PATTERN_LEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>customCharSlot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add new custom character pattern The new pattern will be stored in the custom generator RAM of the lcd controller, the 1602 can store 8 5x8 or 4 5x10 pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charPattern</td><td>array storing the byte patterns, generate them using the link in the README </td></tr>
    <tr><td class="paramname">customCharSlot</td><td>what slot to store the new pattern at, there should be 8 slot if 5x8 font is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d5c1401c84bbaa553624bf7bfc4b74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5c1401c84bbaa553624bf7bfc4b74e">&#9670;&nbsp;</a></span>parallelDataRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::parallelDataRead </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>readDataBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>totalReadData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for reading the data from the controller RAM/program memory The method will follow procedures outlined in the datasheet to intiate and read data from the controller, if using 4 pins it will take two transfers to deliver 8 bits instead of 1 if using 8 pins </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDataReg</td><td>true if reading from the data memory(like RAM), false if reading from lcd controller register(where it has things like the busy status) </td></tr>
    <tr><td class="paramname">readDataBuf</td><td>buffer for storing the data, array of byte </td></tr>
    <tr><td class="paramname">totalReadData</td><td>how many bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af68868010d59b575695e32003e566390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68868010d59b575695e32003e566390">&#9670;&nbsp;</a></span>parallelDataWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::parallelDataWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for sending data to the data pins(D0-D7) connected to the LCD The bits are shifted to each pin and then a proper setup and hold time is followed to make sure that the controller receives the data, the method will follow the correct procedure to intitiate connection with the controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataList</td><td>array of data to be sent </td></tr>
    <tr><td class="paramname">dataLen</td><td>how many byte to send </td></tr>
    <tr><td class="paramname">isDataReg</td><td>is the destination data memory(like RAM) or lcd controller memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30d39861c1faba7371d17be41b7011bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d39861c1faba7371d17be41b7011bb">&#9670;&nbsp;</a></span>parallelDataWriteSingle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::parallelDataWriteSingle </td>
          <td>(</td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataReg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for writing a single byte to the lcd controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the byte to be written </td></tr>
    <tr><td class="paramname">isDataReg</td><td>is the destination data memory(like RAM) or lcd controller memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa91d0a21ac75d28bafbbd674ef566555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91d0a21ac75d28bafbbd674ef566555">&#9670;&nbsp;</a></span>parallelModeSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::parallelModeSwitch </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>switch all the data pins(like D0-D7) to input mode or output mode Used for quickly switching between receiving and sending data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isInput</td><td>if true then all data pin becomes input else become output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cbfe7221754786680d8bca6d8500539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbfe7221754786680d8bca6d8500539">&#9670;&nbsp;</a></span>pinDescCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::pinDescCheck </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinDesc</em>[PIN_DESCRIPTION_LEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether the array describing a pin is valid, will raise assert if not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDesc</td><td>array describing the pin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e6060a18e4cad2b7e141b4c80da96bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6060a18e4cad2b7e141b4c80da96bc">&#9670;&nbsp;</a></span>pinModeSwitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::pinModeSwitch </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pinDesc</em>[PIN_DESCRIPTION_LEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>switch a single pin to input/output </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDesc</td><td>array describing the pin </td></tr>
    <tr><td class="paramname">isInput</td><td>if true, set pin to input, otherwise, set pin to false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93289cc0da86c9081c6078aaddef9c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93289cc0da86c9081c6078aaddef9c57">&#9670;&nbsp;</a></span>pinPadConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::pinPadConfig </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pinDesc</em>[PIN_DESCRIPTION_LEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>configure the pins on things like drive strength(affect rise/fall time of signal), push/pull mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDesc</td><td>array describing the pin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30f8e8816db117e129c29bdbf8fdca3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8e8816db117e129c29bdbf8fdca3d">&#9670;&nbsp;</a></span>pinRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lcddriver::LcdDriver::pinRead </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pinDesc</em>[PIN_DESCRIPTION_LEN]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read whehther a pin is high or low. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDesc</td><td>array describing the pin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true pin is high </dd>
<dd>
false pin is low </dd></dl>

</div>
</div>
<a id="ac39e98eb8654648d6cca19c63aca0398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e98eb8654648d6cca19c63aca0398">&#9670;&nbsp;</a></span>pinWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::pinWrite </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pinDesc</em>[PIN_DESCRIPTION_LEN], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>switch on/off a pin This is the lowest level function, used for toggling control pin for bitbanging during communcication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDesc</td><td>array describing the pin </td></tr>
    <tr><td class="paramname">output</td><td>if true, set pin to high, otherwise, set to low </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68acf86a54398434990ed133f19e0be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68acf86a54398434990ed133f19e0be6">&#9670;&nbsp;</a></span>ramDataRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::ramDataRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>returnData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>totalDataRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>startingRamAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataRam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for reading the RAM of the lcd controller, it can either be the data ram storing data to be displayed or the character generator ram, storing custom pattern The reading operation may result in the cursor moving. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnData</td><td>the buffer to store received data </td></tr>
    <tr><td class="paramname">totalDataRead</td><td>how many bytes to read from the RAM </td></tr>
    <tr><td class="paramname">startingRamAddr</td><td>starting address of the RAM, depending on the type of memory selected the method will append the correct bits to indicate the correct memory region, for example, for DDRAM, bit 7 is set </td></tr>
    <tr><td class="paramname">isDataRam</td><td>true if reading from data RAM(DDRAM), false if from character generator RAM(CGRAM) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d517b0e77d0b957b2c84d6bba76d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d517b0e77d0b957b2c84d6bba76d97">&#9670;&nbsp;</a></span>ramDataWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::ramDataWrite </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isTextMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the RAM of the lcd controller, can be data ram or character generator RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>arrays of data to be written </td></tr>
    <tr><td class="paramname">dataLen</td><td>len of the array of data </td></tr>
    <tr><td class="paramname">isTextMode</td><td>true if in text mode, text mode is helpful for writing to data RAM to be displayed, text mode will interpret special character like <br />
 or $ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992046369aafb0c93d9eb02b0e5fbc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992046369aafb0c93d9eb02b0e5fbc64">&#9670;&nbsp;</a></span>registerSelect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lcddriver::LcdDriver::registerSelect </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>isDataReg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>select data(like RAM) or program register be switching the RS line </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDataReg</td><td>if true then the RS line is pulled high to indicate that transaction will target RAM region, otherwise target the lcd controller program memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="lcd__driver_8hpp_source.html">lcd_driver.hpp</a></li>
<li>src/<a class="el" href="lcd__driver_8cpp.html">lcd_driver.cpp</a></li>
<li>src/<a class="el" href="lcd__utils_8cpp.html">lcd_utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
